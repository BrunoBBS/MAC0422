\documentclass[12pt,a4paper]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{times}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[bottom=2cm,top=2cm,left=2cm,right=2cm]{geometry}
\usepackage{indentfirst} %% To identity the first line of the paragraphs

\title{Relatório do EP2\\MAC0422 -- Sistemas Operacionais -- 2s2017}
\author{Anderson Andrei da Silva (8944025), Bruno Boaventura Scholl (9793586), Victor Seiji Hariki (9793694)}
\date{}

\begin{document}
\maketitle

\section{Introdução}

\subsection{O problema}

     Uma das varias modalidades de ciclismo realizada em velodromos é a corrida por pontos. O objetivo deste EP será simular essa modalidade. Todas os detalhes estão descritos no arquivo \textbf{ep2.pdf} presente na pasta \textit{documentation} que se encontra no diretório do projeto.

%% Apresentar a organização do EP -- Todos os arquivos presentes no
%% .tar.gz, para que serve cada um deles, etc...
\subsection{Disposição dos arquivos} 

    Os arquivos estão dispostos da seguinte maneira:
    \begin{itemize} %pastas
    
    \item Na \textbf{raiz do diretório} se encontram : Makefile, relatório (em LaTex) e as pastas descritas a seguir;
    \item Na pasta \textbf{execsrc} se encontram dispostos todos os arquivos que gerarão executáveis:
        
    \begin{itemize} %arquivos
    \item ep2.c : %%colocar o cabeçalho de cada aquivo aqui
    \end{itemize} %arquivos
    
    \item Na pasta \textbf{src} se encontram todos os arquivos em c que serão utilizados mas não gerarão executáveis:
    
    \begin{itemize} %arquivos
    \item rider.c : %%colocar o cabeçalho de cada aquivo aqui
    \item velodrome.c : %%colocar o cabeçalho de cada aquivo aqui
    \end{itemize} %arquivos
    
    \item Na pasta \textbf{include} se encontram todos os arquivos de include (.h) que serão utilizados nos outros dois casos:
     
    \begin{itemize} %arquivos
    \item ep2.h : %%colocar o cabeçalho de cada aquivo aqui
    \item reider.h : %%colocar o cabeçalho de cada aquivo aqui
    \item typedef.h : %%colocar o cabeçalho de cada aquivo aqui
    \item velodrome.h : %%colocar o cabeçalho de cada aquivo aqui
    \end{itemize} %arquivos
    
    \item Na pasta \textbf{documentation} se encontram :
    
        \begin{itemize} %%arquivos
        \item ep2.pdf : o enunciado deste exercício programa;
        \item relatorio-ep2-trio.pdf : este relatório;
        \item apresentacao.pdf : a apresentação do projeto em slides.
        \end{itemize} %%arquivos
        
    \item Na pasta \textbf{bin} se encontra o binário \textit{ep2}.
    
    \item Na pasta \textbf{obj} se encontram os arquivos \textit{.o} criados pela compilação.
    
    \item Na pasta \textbf{testsrc} se encontra um código criado para testar o programa que torna visível a corrida, \textit{graphical.c} .

    \item Na pasta \textbf{testbin} se encontra o binário do código de testes, \textit{graphical}.
    
    \end{itemize} %pastas

%%Apresentar o algoritmo de cada ciclista e o algoritmo geral do código,
%%destacando cada um dos mecanismos utilizados que tenham sido vistos na
%%sala de aula. Cada um desses mecanismos deverá ser mais detalhado nas
%%subseções a seguir (os títulos são exemplos supondo que eles tenham
%%sido usados)
\subsection{Algoritmos}

    Para a resolução do problema, foram criados e utilizados pelo grupo os seguintes algoritmos:
    
\subsubsection{Ciclistas}

    Os ciclitas serão representados cada um por uma thread, tendo como características específicas:
    
    \begin{itemize}
    \item int id;
    \item {pthread\_t rider\_t};
    \item Velodrome velodrome;
    \item int speed;
    \item bool broken;
    \item int score;
    \item int {total\_dist};
    \item int lane;
    \item int {step\_time};
    \item uint turn;
    \item {sem\_t turn\_done};
    \item int *overtake;
    \end{itemize}

    O conjunto de todos eles será representado por um vetor de threads. Pontos como a movimentação de cada um deles será melhor descrita na seção THREADS.
    
    Por serem o método de representação dos ciclistas sua função principal é "correr" e algoritmo segue principalmente o seguinte pseudocódigo:
    
    \begin{itemize}
    \item set initial speed
    \item wait start
    \item if lap completed   
    \begin{itemize}
      \item choose new speed
      \item check if scores
      \item if lap is multiple of 15
      \begin{itemize}
        \item decide if breaks
      \end{itemize}
    \end{itemize}
    \item go forward, left or right
    \begin{itemize}
      \item if is a rider in front
      \begin{itemize}
        \item wait rider in front, left or right do its turn
        \item checks max speed possible and reduce if needed
      \end{itemize}
    \end{itemize}
    \item notify rider behind semaphore
    \item notify global barrier
    \item wait global barrier
    \end{itemize}
    
\subsubsection{Velódromo}

    Para simular a corrida, dado um vetor de threads, cada thread será disparada a cada ciclo , que representam 60 ms reais, e de acordo com suas características em cada volta (velocidade, pista, etc.) desempenharão seu rendimento. Cada uma é disparada por vez, com ordem estipulada especificamente pelo SO, e o que diferenciará o rendimento individual de cada uma serão suas características, que serão contabilizadas e agregadas a cada ciclo. E assim, teremos então diferentes desempenhos por ciclos e em uma visão geral, teremos a simulação da corrida.
    
    O gerenciador de tudo que foi descrito à cima , assim como dos cicilistas, pontuações e etc é o \textbf{velódromo}, que possui as seguintes características:
    
    \begin{itemize}
    \item int length; // Length of velodrome, in meters
    \item {uint rider\_cnt}; // Total number of riders
    \item {uint a\_rider\_cnt}; // Number of active riders
    \item {uint lap\_cnt}; // Turn count
    \item int **pista;
    \item struct Rider *riders;
    \item {pthread\_t coordinator\_t};
    \item {pthread\_barrier\_t start\_barrier};
    \item {sem\_t velodrome\_sem};
    \item {int round\_time}; // How much time passes in one barrier round
    \item {sem\_t *arrive};
    \item {sem\_t *continue\_flag}; // Flag to pass barrier
    \item int *placings; // Remaining riders
    \item {int *s\_indexes}; // Stack of placings by round
    \item {uint **placings\_v};
    \item {sem\_t rand\_sem}; // Random generator semaphor    
    \end{itemize}

    E tem por seu algoritmo principal o seguinte pseudocódigo:
    
    \begin{itemize}
    \item Alocate the struct Velodrome
    \item Start the semphores (blocked)
    \item Alocate the track
    \item Alocate the stack of scores
    \item Create the riders
    \item Crate the placings
    \item Start the riders
    \begin{itemize}
      \item Start the global barrier - \textit{pthread\_barrier\_init}
      \item Create the threads - \textit{pthread\_create}
      \item Create the coordenator %%Esperar pra ver como o shcoll vai fazer a barreira
      \item Wait the threads - \textit{pthread\_barrier\_wait} %%Confirmar essa descriçao de esperar as threads
    \end{itemize}
    \end{itemize}
    
    %%ver se o pessoal acha que deve ter
    
    Fora isso, o velódromo ainda pode executar as seguintes funções:
    
    
    \begin{itemize}
    \item void create\_velodrome(Velodrome *velodrome\_ptr, uint length, uint                   rider\_cnt, uint lap\_cnt); // Creates new velodrome struct
    \item void destroy\_velodrome(Velodrome *velodrome\_ptr); // Destroys velodrome             object
    \item int max\_rider\_speed(Velodrome *velodrome\_ptr, Rider rider); // Returns max         speed cyclist can
    \item Rider rider\_in\_front(Rider behind); // Returns rider in front of parameter
    \item bool can\_rider\_break(Velodrome *velodrome\_ptr); // If there are more than          5 riders
    \item void mark\_sprint(Rider rider, int lap); // Mark sprints
    \item void mark\_overtake(Rider rider); // Mark overtakes
    \item void mark\_lap(Rider rider, int lap); // Mark lap
    \item bool is\_sprint(Velodrome *velodrome\_ptr, Rider rider); // Verify if the             turn is a sprint
    \item int compare\_scores(const void * a, const void * b); // Compare the score to          qsort()
    \item void print\_info(uint *id, Velodrome velodrome\_ptr); // Print infos how              scores or positions
    \end{itemize}

    
%%Explicar para que foram usadas barreiras (em todos os lugares onde
%%foram usadas), como foram implementadas (se foi implementado algum
%%algoritmo visto em sala de aula ou se foi usada alguma função pronta).
%%Caso tenha usado alguma função pronta, expliar o que ela faz por
%%"baixo dos panos".

\subsection{Barreiras de sincronização}

    Foram utilizadas as barreiras de sincronizações para tratar dois pontos vitais. 
    
    O primeiro, a largada, temos de esperar que todos as threads sejam devidamente carregadas, como se os ciclistas estivem se posicionando na pista, para que a corrida possa começar. Assim sendo, a primeira barreira sincroniza a criação e a preparação de todas as threads para a largada.
    
    O segundo ponto, o disparo das threads (riders). O grupo implementará a execução das threads conforme será descrito nas próximas seções. Mas para tal, a cada execução do ciclo, a ordem da execução das threads é desconhecida pelo grupo pois depende do SO. O que pode então resultar na execução sempre da mesma thread, pois ela pode ser muito rápida e terminar sua tarefa antes que outra seja selecionada, podendo assim ser escolhida novamente. Utilizando a barreira nesse ponto, dessa forma, evitamos colocar sempre a mesma thread em execução, e fazemos todas as threads serem executadas a cada ciclo.

    Para tal implementação foi utilizada a biblioteca \textbf{pthread.h} que possibilita o uso de threads e barreiras para elas:
    \begin{itemize}
    \item  \textbf{pthread barrier init} : Inicia uma barreira;
    \item  \textbf{pthread barrier wait} : Faz a barreira barrar 
    \end{itemize}


%%Explicar para que foram usados semáforos (em todos os lugares onde
%%foram usados).
\subsection{Semáforos}

    Serão utilizados para controlar a posição e movimenação dos ciclistas na pista.
    
    Conforme teremos casos nos quais vários ciclistas estarão na mesma pista, o ciclista da frente é o limite de movimentação do anterior. Sendo assim, as threads que estão atrás tem que esperar a da frente se mover. Assim sendo, utilizaremos semáforos nesse ponto para poder impedir a possível movimentação (seleção do sistema daquela determinada thread) de ciclistas que estão impossibilitados por tal motivo. Logo, a movimentação so é liberada quando o semáforo permitir, que fará isso após a movimentação dos ciclistas da frente. 
    Um para o range
    
        Para tal implementação foi utilizada a biblioteca \textbf{semaphore.h} que possibilita o uso de semáforos:
    \begin{itemize}
    \item  \textbf{sem\_post} : Soma um no semáforo;
    \item  \textbf{sem\_wait} : Espera a liberação dele.
    \end{itemize}

%%Explicar para que foram usadas threads (em todos os lugares onde foram
%%usadas).
\subsection{Threads}

    As threads representarão os riders (ciclitas) e terão suas características como já descrito na seção 1.3.2. Ao ser criada, uma thread receberá suas características e se posicionará na pista, aguardando o iniício da corrida. Cada execução será feita dentro de um ciclo que representa 60 ms (em geral, mas os dois últimos representarão 20 ms). A cada ciclo os dados de cada thread é atualizado, de forma a simular seu desempenho na corrida. Para igualar as condições de todas as threads, essas passarão por 2 barreiras (descritas na seção 3).
    
    A função principal de cada thread é "correr", e para tal, a função que simula tal movimento verifica todas as condições possíveis para os casos de aceleração e redução de velocidade, ultrapassagem, pontuação a cada sprint, bonificação (no caso de um corredor der uma volta completa em todos os outros) e até mesmo quebra da bicicleta.
    
    Para os casos de aumento e redução de velocidade, os ciclitas podem mudar entre 30, 60 e até 90 ms. Será computado de forma a ser visível nos logs distâncias percorridas a cada 1 metro. Assim sendo, ciclistas que estiverem a 30 ms e assim se mantiverem, ao completar o primeiro ciclo não terão percorrido 1m, e a nível de implementação, permancerão no mesmo ponto onde estavam no início do ciclo e só se moverão ao término do segundo, tendo então se movimentado por 1m.
    
    Corredos que "quebrarem" são imediatamente removidos da corrida, e a thread que o representa é destuída.
    
    Serão exibidas informações das threads conforme requisitado no enunciado deste trabalho, assim como existirá um modo \textit{debug} que ilustrará melhor a corrida.


\section{Resultados}

Explicar como foram feitos os experimentos (se manualmente ou se
usando alguma linguagem de script ou algo similar. Caso tenha usado
algo automatizado, explicar brevemente como funcionou).

Explicar os resultados (os gráficos que já foram pedidos no
enunciado) deixando claro se foram os esperados ou não. \textbf{Todos}
os gráficos precisam ser citados no texto. Não pode simplesmente
``jogar'' 100 gráficos aqui e falar algo como: ``Em todos os gráficos
pode ser visto...''. Tem que explicar um por um mesmo que a explicação
fique repetitiva. Até pode-se fazer referência a um resultado similar
escrevendo algo como: ``Como pode-se ver no gráfico da Figura 1, o
resultado foi similar ao gráfico da Figura 2 pois ...''.

\section{Divisão das tarefas de implementação}

Mostrar como ficou a dedicação de cada membro da equipe em termos de
implementação. É altamente recomendado que aqui seja apresentada a
saída de algum repositório que já gere o histórico dos
\texttt{commits}.

\section{Referências}

Colocar todas as referências usadas para a escrita do relatório (Se
vocês souberem usar bibtex, podem usar. Se não souberem usar, sem
problemas simplesmente listar as referências aqui).

\end{document}
