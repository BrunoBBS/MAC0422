\documentclass[12pt,a4paper]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{times}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[bottom=2cm,top=2cm,left=2cm,right=2cm]{geometry}

\title{Relatório do EP2\\MAC0422 -- Sistemas Operacionais -- 2s2017}
\author{Anderson Andrei da Silva (8944025), Bruno Boaventura Scholl (9793586), Aluno 3 (NUSP)}
\date{}

\begin{document}
\maketitle

\section{Introdução}

\subsection{O problema}

      Uma das varias modalidades de ciclismo realizada em velodromos é a corrida por pontos. O objetivo deste EP sera simular essa modalidade. Todas os detalhes estão descritos no arquivo \textbf{ep2.pdf} presente no diretório do projeto.

%% Apresentar a organização do EP -- Todos os arquivos presentes no
%% .tar.gz, para que serve cada um deles, etc...
\subsection{Disposição dos arquivos} 
    
    bin  obj testbin  testsrc

    Os arquivos estão dispostos da seguinte maneira:
    \begin{itemize} %pastas
    
    \item Na \textbf{raiz do diretório} se encontram : Makefile, relatório (em LaTex) e as pastas descritas a seguir;
    \item Na pasta \textbf{execsrc} se encontram dispostos todos os arquivos que gerarão executáveis:
        
    \begin{itemize} %arquivos
    \item ep2.c : %%colocar o cabeçalho de cada aquivo aqui
    \end{itemize} %arquivos
    
    \item Na pasta \textbf{src} se encontram todos os arquivos em c que serão utilizados mas não gerarão executáveis:
    
    \begin{itemize} %arquivos
    \item rider.c : %%colocar o cabeçalho de cada aquivo aqui
    \item velodrome.c : %%colocar o cabeçalho de cada aquivo aqui
    \end{itemize} %arquivos
    
    \item Na pasta \textbf{include} se encontram todos os arquivos de include (.h) que serão utilizados nos outros dois casos:
     
    \begin{itemize} %arquivos
    \item ep2.h : %%colocar o cabeçalho de cada aquivo aqui
    \item reider.h : %%colocar o cabeçalho de cada aquivo aqui
    \item typedef.h : %%colocar o cabeçalho de cada aquivo aqui
    \item velodrome.h : %%colocar o cabeçalho de cada aquivo aqui
    \end{itemize} %arquivos
    
    \item Na pasta \textbf{documentation} se encontram :
    
        \begin{itemize} %%arquivos
        \item ep2.pdf : o enunciado deste exercício programa;
        \item relatorio-ep2-trio.pdf : este relatório;
        \item apresentacao.pdf : a apresentação do projeto em slides.
        \end{itemize} %%arquivos
        
    \item Na pasta \textbf{bin} se encontram 
    
    \item Na pasta \textbf{obj} se encontram 
        
    \item Na pasta \textbf{testbin} se encontram 
    
    \item Na pasta \textbf{testsrc} se encontram 

    \end{itemize} %pastas


%%Apresentar o algoritmo de cada ciclista e o algoritmo geral do código,
%%destacando cada um dos mecanismos utilizados que tenham sido vistos na
%%sala de aula. Cada um desses mecanismos deverá ser mais detalhado nas
%%subseções a seguir (os títulos são exemplos supondo que eles tenham
%%sido usados)
\subsection{Algoritmos}

    Para a resolução do problema, foram criados e utilizados pelo grupo os seguintes algoritmos:
    
\subsubsection{Ciclistas}

    Os ciclitas serão representados cada um por uma thread, tendo suas características específicas POR AS CARACTERÍSTICAS DELES (VELOCIDADE, PISTA E MAIS O Q ?). O conjunto de todos eles será representado por um vetor de threads.
    Pontos como a movimentação de cada um deles será melhor descrita na seção THREADS.
    Por serem o método de representação dos ciclistas sua função principal é "correr" e algoritmo segue principalmente o seguinte pseudocódigo:
    
    \begin{itemize}
    \item wait start
    \item if lap comleted:   
    \begin{itemize}
      \item choose new speed
      \item check if scores
      \item if lap is multiple of 15:
    \end{itemize}
    \item decide if breaks
    \item go foraward, left or right:
    \begin{itemize}
      \item if is a rider in front:
      \begin{itemize}
        \item wait rider in front, left or right do its turn
        \item       chacks max speed poddible and reduce if needed
      \end{itemize}
    \end{itemize}
    \item notify rider behind semaphore
    \item notify global barrier
    \item wait global barrier
    \end{itemize}
    
\subsubsection{Corrida}

    Para simular a corrida, dado um vetor de threads, cada thread será disparada a cada ciclo , que representam 60 ms reais, e de acordo com suas características em cada volta (velocidade, pista, etc.) desempenharão seu rendimento. Cada uma é disparada por vez, com ordem estipulada especificamente pelo SO, e o que diferenciará o rendimento individual de cada uma serão suas características, que serão contabilizadas e agregadas a cada ciclo. E assim, teremos então diferentes desempenhos por ciclos e em uma visão geral, teremos a simulação da corrida.
    
%%Explicar para que foram usadas barreiras (em todos os lugares onde
%%foram usadas), como foram implementadas (se foi implementado algum
%%algoritmo visto em sala de aula ou se foi usada alguma função pronta).
%%Caso tenha usado alguma função pronta, expliar o que ela faz por
%%"baixo dos panos".

\subsection{Barreiras de sincronização}

    Foram utilizadas as barreiras de sincronizações para tratar dois pontos vitais. 
    O primeiro, a largada, temos de esperar que todos as threads sejam devidamente carregadas, como se os ciclistas estivem se posicionando na pista, para que a corrida possa começar. Assim sendo, a primeira barreira sincroniza a criação e a preparação de todas as threads para a largada.
    O segunod ponto, o disparo das threads (riders). O grupo implementará a execução das threads conforme será descrito nas próximas seções. Mas para tal, a cada execuçã do ciclo, a ordem da execução das threads é desconhecida pelo grupo pois depende do SO. O que pode então resultar na execução sempre da mesma thread, pois ela pode ser muito rápida e terminar sua tarefa antes que outra seja chamada, podendo assim ser escolhida novamente. Utilizando a barreira nesse ponto, dessa forma, evitamos colocar sempre a mesma thread em execução, e fazemos todas as threads serem executadas a cada ciclo.

    Para tal implementação foi utilizada a biblioteca \textbf{pthread.h} que possibilita o uso de threads.


%%Explicar para que foram usados semáforos (em todos os lugares onde
%%foram usados).
\subsection{Semáforos}

    Serão utilizados para controlar a posição e movimenação dos ciclistas na pista.
    Conforme teremos casos nos quais mais de um corredor estarão na mesma pista, o corredor da frente é o limite de movimentação do anterior. Sendo assim, as threads que estão atrás tem que esperar a da frente se mover. Assim sendo, utilizaremos semáforos nesse ponto para poder impedir a possível movimentação (seleção do sistema daquela determinada thread) de ciclistas que estão impossibilitados por tal motivo. Logo, a movimentação so é permitida quando o semáforo permitir, que fará isso após a movimentação dos ciclistas da frente. 

%%Explicar para que foram usadas threads (em todos os lugares onde foram
%%usadas).
\subsection{Threads}

    As threads representarão os riders (ciclitas) e terão suas características como já descrito na seção 1.3.2. Ao ser criada, uma thread receberá suas características e se posicionará na pista, aguardando o iniício da corrida. Cada execução será feita dentro de um ciclo que representa 60 ms (em geral, mas os dois últimos representarão 20 ms). A cada ciclo os dados de cada thread é atualizado, de formaa simular seu desempenho na corrida. Para igualar as condições de todas as threads, essas passarão por 2 barreiras (descritas na seção 3).
    A função principal de cada thread é "correr", e para tal, a função que simula tal movimento verifica todas as condições possíveis para os casos de aceleração e redução de velocidade, ultrapassagem, pontuação a cada sprint, bonificação (no caso de um corredor der uma volta completa sob todos os outros) e até mesmo quebra da bicicleta.
    Para os casos de aumento e redução de velocidade, os ciclitas podem mudar entre 30, 60 e até 90 ms. Será computado de forma a ser visível nos logs distâncias percorridas a cada 1 metro. Assim sendo, ciclistas que estiverem a 30 ms e assim se mantiverem, ao completar o primeiro ciclo não terão percorrido 1m, e a nível de implementação, permancerão no mesmo ponto onde estavam no início do ciclo e só se moverão ao término do segundo, tendo então se movimentado por 1m.
    Corredos que "quebrarem" são imediatamente removidos da corrida, e a thread que o representa é destuída.


\section{Resultados}

Explicar como foram feitos os experimentos (se manualmente ou se
usando alguma linguagem de script ou algo similar. Caso tenha usado
algo automatizado, explicar brevemente como funcionou).

Explicar os resultados (os gráficos que já foram pedidos no
enunciado) deixando claro se foram os esperados ou não. \textbf{Todos}
os gráficos precisam ser citados no texto. Não pode simplesmente
``jogar'' 100 gráficos aqui e falar algo como: ``Em todos os gráficos
pode ser visto...''. Tem que explicar um por um mesmo que a explicação
fique repetitiva. Até pode-se fazer referência a um resultado similar
escrevendo algo como: ``Como pode-se ver no gráfico da Figura 1, o
resultado foi similar ao gráfico da Figura 2 pois ...''.

\section{Divisão das tarefas de implementação}

Mostrar como ficou a dedicação de cada membro da equipe em termos de
implementação. É altamente recomendado que aqui seja apresentada a
saída de algum repositório que já gere o histórico dos
\texttt{commits}.

\section{Referências}

Colocar todas as referências usadas para a escrita do relatório (Se
vocês souberem usar bibtex, podem usar. Se não souberem usar, sem
problemas simplesmente listar as referências aqui).

\end{document}
